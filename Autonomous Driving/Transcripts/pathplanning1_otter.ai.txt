Unknown Speaker  0:00  
We are now reaching the path planning part of the lecture to repeat the goal. The goal of this motion planning part of this year's lecture is for you to learn the basic concepts and algorithms for path planning. And to understand how they apply to autonomous cars, you should understand the approaches how they report the approaches relate to each other, such that then when you want a situation that you have to problem your own autonomous behaviour for a vehicle or robot, or similar devices, you have a good understanding of which kind of algorithm to select what are the upsides and the downsides. However, before we get into the actual planning, we need some understanding of the dynamics of the kinematics of the vehicles we're trying to control. So, we will be looking at this in two parts. Part One will be more about the kinematics about the constraints will help us understand the basic single track model, it will help us understand how we can deal with obstacles. With regards to our path learning. It will help us how to perform simple collision checks for our vehicles. And afterwards, we will take a look at the algorithms we can use in order to achieve our path setting. Let's look at how we could structure tasks for path planning. The first one we're going to look at is the basic task, you can see an image to the right of the screen, we have starting location A and then we have a goal location B. And the task for the robot is to find the path from the configuration A to the configuration B by configuration here applies that not only should it find its way from the first position to the end position, but also also it should have a certain orientation at the end. While doing so it should respect all given constraints, which could be non holonomic constraints, which could be constraints with regards to the specifics of the curvature that is continuous, it could be constraints with regards to obstacles. And we want to figure out what these constraints could look like and how they impact us. Considering a parking task, we're assuming there is a parking spot and we're trying to get into it, the parking cars around us are static, there is maybe not so much space available, we want to be effective about the space usage, we want to get into small parking spots, we have some time to achieve it. Typically, while you want to swiftly finish a parking manoeuvre. It's not like on the highway where even in milliseconds, vehicles perform quite significant movements. Thinking back to the Robin OS example discussions, you remember all these models that we analysed for lanes for road structures. Now thinking about unstructured environments environments where you have a lot of freedom about selecting your specific path, you can look at the parking spot example on the right where you might be starting at the bottom and you have to select the parking spot. And many different paths could actually lead you to an acceptable goal. However, some paths might be more optimal than others. As opposed to parking spots on highways, you might encounter much higher speeds, you might also have increased risks during collisions due to the increased speeds. And often you think about driving on highways in terms of manoeuvres that you can perform performing a lane switch going from one lane to another, performing a takeover manoeuvre, pursuing a car ahead of you trying to escape a car behind you driving at constant speed along the highway, similar to an ACC distance keeping system. structure is often very important in these scenarios. However, if you encounter constructions sites, if you encounter accident locations, you could also encounter unstructured scenarios within a highway. Going up the abstraction train, you could consider route planning on a map. You have an abstracted map here maybe you have a list of notes that you're trying to traverse one after another in order to get from your high level starting location to your goal.

Unknown Speaker  4:42  
We talked about thinking about driving on highways in terms of manoeuvre, you might want to pursue lane change or you might want to follow your lane. However, as you might know from your own personal driving practice, depending on how dense the traffic is, it might Not even be that easy to make lane change even if you so desire, so the other car could close the distance while you're still trying to merge into it. So you need to identify a good strategy in order to successfully realise your traffic manoeuvre. So now marking in green, different gaps that you could try to get into, you could make a high level decision where you choose a strategic goal. And then you could have a power planner execute this motion, thinking back to the individual parking scenario where the cars around us stationary, you can imagine if you take long time to calculate a path with your algorithm, let's just say 30 seconds to calculate the best solution of how you want to make your lane change, then, obviously, all these cars might already have moved on and the situation might be very different. So the path that you calculated might not be valuable anymore. Sometimes for achieving these strategic decisions, versus making these concrete paths, you have options, you could use learning algorithms, you could use classical algorithms. And depending on the characteristics of your of your tasks that you're currently trying to achieve or how your sub structured, you have different requirements. So also combinations of algorithms could be a good path to go. If we want to compute paths for robots for vehicles, then we need we profit greatly from having sensible mathematical models that describe based on the input that we provide where the robot will move. So here we have an example, we can see that we could define the XY positions of a robot. So this would mean driving in a two dimensional coordinate system, for example, on a flat road, and then always, it's also interesting to know how the robot is oriented or the vehicle is oriented. You can imagine that depending on the orientation of, of a classical car, you cannot go into any direction, you can only go forwards, you can go backwards, you can turn your steering wheel, but you can't go directly sideways with a car. However, other robots could have different kinds of reconstructions. And for every machine, we need to make a good model to understand how can we actually move it, in order to derive a plan of how do we want to move it in order to achieve our goal, you can see at the bottom that we have here, the derivatives of the x, y and z depose to these UX UI, which typically represent inputs, which means that we can impact the system. And depending on which components of the robot we can actually directly control and how our Control F ultimately affects the robot movement. We will have we will see different models here. Let's take a look at some robots that can easily move in any kind of direction. And they'd have to go to move these small ice hockey like books around. This is from a robotics competition. And you can see that they can move and rotate quite independently.

Unknown Speaker  8:47  
We're going to separate holonomic and nonholonomic systems represented by their corresponding constraints. holonomic constraints means that we have constraints that limit the possible state transitions. That could for example, mean that the robot cannot leave a certain area. It could mean that a robot cannot leave the surface area of a sphere as expressed

Unknown Speaker  9:18  
here.

Unknown Speaker  9:25  
And you can see that all these constraints can be written without using any derivatives with regards to time. It means that any reachable configuration can be reached by simple motion, and that the robot can directly drive to a goal configuration without having to do some manoeuvring actions or rotating actions before. Now, let's look at an example with You can see that if this vehicle would just be able to move in any direction and throw it on the spot, this parking manoeuvre would have been so much easier for the driver. Here we can see the difference of the non holonomic constraints versus the holonomic constraints that we just looked at the non holonomic constraints may depend on the derivatives of state arrivals. So thinking back about the car example, a wheel may only move in one direction for example, as you can see here with the derivative of y equaling the sine of theta, which means the current orientation of the vehicle expressing that you cannot just freely drive to the side. But instead you have to perform rotating manoeuvres in order to reach spots nearby nonholonomic systems can reach states using a combination of motions, which they can read using simple motions, you can just rotate and immediately draw drive to the goal configuration. But you have to combine a number of manoeuvres depending on your starting point or the end goal, we need a little bit more in order to model our vehicles motion. We already defined some variables similar some slides ago, to express the position to express the orientation, we are now defining the the coordinate systems with regards to the cars you can see that is, in this case, on this slide, the coordinate system is placed in the centre of the rear axle of the vehicle, which would be here was marked in red. This is not a law of physics, you could also define different anchor points for coordinate systems, you could also place them on the ground, you could place them in the middle of the wheel. So typical thing to do is if this is the car, where to place the coordinate system in the middle of the wheel, but sometimes people also like to place the coordinate system directly on the road. And then this is sometimes decided based on the types of wheels that you have with your robots, if they are solid or not, then any implications of these choices. Also, depending on the road, being flat or having inclinations, for now, just realise that this topic exists. And if you ever work on robot make it very, very clear that everybody has the same understanding of where these coordinate systems are. Another very important thing is the turning radius, which defines how much space you need in order to perform recording turn. This is all basic mathematics, you can find proofs for these models. Online, the single track model that we're looking at here is very famous, the name mostly comes from acting as if the if there would be just the singer director the the vehicle is following while driving. Instead of having multiple tracks with multiple widths and so on, it's a simple model. And it works quite well for four simple motions. If we assume that every calculation is done for small time steps, then we can derive all our necessary model equations through simple trigonometry.

Unknown Speaker  14:12  
Then, of course, understand that if we violate these assumptions, and we instead making calculations for very long time steps, then this becomes more and more unsound. Or if we violate things like the friction of the ground that we're driving so far, so we're driving on is that we're sliding around that we have very strong wind effects. We get more and more violations of our models, but as I said, this is a well liked model for simple driving cases. Similarly, we can, as we have on the last page derived the change in x and y coordinates, we can calculate our turning radius again using simple trigonometry, if we assume these smaller time steps and these approximations with regards to the friction and so on. So I encourage you to check this out and at home, as long as you as you desire. Combining this, we can arrive at our symmetric model, which gives us a nice relation between our input arrivals, which are also often called extra variables, the distance between our rectangles and the output variables, the x coordinate of the vehicle and the y coordinate of the vehicle, and the rotation of the vehicle. And we can calculate each next step. And numerically, as I'm sure you've seen in a variety of lectures, or we'll see in a variety of lectures in the future. For emphasis, let's take a short look at a situation. So you can easily see that, that we have different surfaces, dry surfaces and wet surfaces. And we also might be in breaking very hard so we have friction issues. If you want to make a system that optimises for such conditions, then you need to make your model a little bit more complicated complex to represent these effects. Let's look at one simple way of extending the model just to give you an impression. So the slide is called extending the singer drag model, we can see here again, the old model that we discussed. And then you see the same model with a few additional entries. And the key message on the slide is to say that if you input in an imaginary way you input yen to your velocity extra variable onto your steering arrival, then the vehicle doesn't immediately change its velocity, right, you first have to accelerate it. So you could also go one level deeper, deeper, and have been models that define how does your input for example, to a steering wheel transition into an actual rotation of the vehicle, which, again, if you're trying to make the perfect sample steering mechanism, then you might want a more complicated model. And so you can always extend or simplify your models. So what we're doing is we're extending the single direct model by adding additional dynamic information. And for planning and controlling, it will be possible to measure all state arrivals of the model. using sensors available in the car. This is easier said than done. Often when you face real systems, they have tolerances, they might be missing certain kinds of sensors and sensor information can be erroneous. So try to set up a good system. For simulation purposes, you sometimes have more freedoms, sometimes you have less information. So you have to make some reasonable trade offs for your for your simulation. This is just a sneak peek at an even more complex model. But by now you should realise many similarities between this more complex model and the model that you have seen on the last slides. And this really is only here to give you an impression of other kinds of forces and frictions that you could involve in your model. And to give you a little bit of a of a view of what this could look like. But also to give you the chance to see that it is somehow similar to what you study before. And if you're interested in more

Unknown Speaker  18:48  
involved variations of these models, he has a source provided that you can can check out of curiosity. For simple scenarios like driving on a horizontal road and a straight line at low velocities with a good car, you can model this very, very well with these approaches, the parameters are easy to tune, and you will get a good match with your experiment with your with your inputs, creating the opposite you also observe in the real world, as in your simulation. However, if you have very complex dynamics, if you are driving, if you're pushing your car to its limits, then the you could also use learning approaches to try to maybe develop some kind of intuitive understanding of situations or to to try to learn the specific parameters of a situation. And of course, then you get other problems like overfitting your model to maybe one specific parking spot where it might not scale out. generalise to other parking spots. If this was to airstrike, let's take a look at the corresponding video.

Unknown Speaker  20:05  
The following video shows our software driving a full sized autonomous car parking in a spot marked by traffic cones. This represents one of the most challenging autonomous driving manoeuvres. In terms of accurate placement with a sliding car. Our system is able to repeatedly execute this manoeuvre with the final position error of about two feet.

Unknown Speaker  20:51  
Here's a definition to memorise but also maybe a small trick for your next parking challenge. We talk about small time local controllability, we're saying that we can only rotate and move in the direction that it is pointing. However, if we use a combination of motions, we can practically move sideways. If we make these motions arbitrarily short, then the system is called small time locally controllable. working our way towards the first planning approaches, the Dubin scan approach is very well known in the automotive domain, we use the models that we just looked at the simple ones, we consider that the actual variable, u v for the velocity is now restricted to one which means for this approach, we don't care if we're driving slower or faster, we just say that we always drive with a speed of one for which you don't even need to define a unit. And we're making a few further rules. So is saying the car can only drive forward with a constant speed. So you can see in the image here that we are not driving backwards, it's crossed out. And we're saying you can only change the the steering angle of the of the wheels, which means you can drive left or right or straight. We define a task that means that we want to find the shortest path from starting position to go position that again includes the x&y position and the orientation of the vehicle. And yeah, now how do we find our our path? Let's consider the path learning problem a bit formally, again, we have defined the constraint that we can only rotate our weeds so much to a certain degree. And within this, we have the possibility to drive left to drive right or to drive straight. And now we can define combinations of these primitive motions, we can call them a word. And we can then express the shortest path from the starting configuration to goal configuration by using one of these six words. So here you would see drive left drive right drive left, or here we see drive right drive straight drive left and on the image, you can see the depending on the on the rotating capabilities of Deegan, the maximum minimum steering angles, how we can drive left or right or straight from the initial configuration. Here's an example of computing the path corresponding to the words right straight left. So we have our initial configuration, and we have our goal configuration, we start with a right circle of the starting configuration. And then we add the left circle of the goal configuration. So please apologise the mouse drawing quality, which we're going to perceive now, we have here surface which are where the diameter is defined, according to the turning radius, and now we can make a right turning circle, this would mean that we're just driving in the right order. And we can make here a left turning circle, this would mean that we're just driving in the left circle. And now if we just connect these two circles with a tangent, this is indicated here. And then we we follow this path there, then we get this word consisting of these three primitive notions, which leads us directly into our goal configuration in a very simple manner. Let's look at a slightly more complicated example. computing the path corresponding to a right left right word. So we draw again, right circle around the initial configuration, indicated here. And then we draw another right circle around the configuration is indicated here. And now if you imagine that you would be taking double this distance, so double the turning radius here, and you would be drawing a circle like that, it would end up some somewhat something like this. And you could do the same thing from over here, you would end up with two kinds of intersections. And if you use this intersection here, that you draw around that left server, which then you do this construction touches these, these two touches these these two hour circuits, then you you will have a path to reach your goal, which in this case, now let's take the final colour

Unknown Speaker  26:02  
would lead you down here now we definitely have too many colours and just just image for for PowerPoint, and up again until you reach your configuration.

Unknown Speaker  26:19  
Now, we have seen how we can construct two different kinds of words for the doin SCA. And if you simply do this for all the possible six words and you compare all of them, then you can select the optimal path among them. But this is not all again, we take it one of the further and we go from the Durbin's car to the Ritz and ship car. And the Ritz and ship car model is very, very similar. But now imagine it is also allowed to drive backwards or constrained for our velocity control rival is now actually going from minus one to plus one. and due to this we get a lot more possible words that we can can construct. However, the general process is very similar. So these two approaches are very easy. But there are also some issues. If you want to construct curvature that you can actually derive with your car, then it would be good if the curvature would be continuous. This is sometimes it's a bit difficult for people to imagine. But you could think about it like this. If you were on a nice circle, you could choose a certain steering angle for your vehicle that would match the circle. And then you continuously drive around the circle. If you were driving on a straight road, adding slowly changes into curve, you could drive drive straight off your steering. And then you could slowly rotate the steering wheel and you smoothly follow the road. And how if you have if you have discontinuities in the curvature of the road that you're following, if you would want to stay perfectly in your lane, print in principle from one, one time point to the next, the car would have would have to immediately change its orientation to some degree and because this is not possible in reality, continuous cultures are preferably. Now the second downside you can see here is that small position changes can lead to large differences concerning the path and which means that your vehicle is placed slightly differently. This could lead to very long, resulting in positive calculate. And you probably some of you might need a drawing to understand this. So initially, we said we have a starting location, and then we have a goal location. And you can imagine that I made some crosses here, but you would probably assume that the centre of the cross is actually the the exact starting in the exact goal position. However, we don't even know our starting position or our goal, our actual location of our vehicle we don't know what to do. And so maybe there's an error loops, within which we assume that our car is located based on all sensor measurements. And maybe our our vehicle is just not it's just not quite hit the goal location. And now in order to go from this point that we reach that might be slightly off from our location, we would have to make some some large transitions in order to get to our perfectly into our goal locations, which means that in practice due to these imperfections or sensors of actuators, and of the huge cost to to to make small parallel transitions with your vehicle. It might be better to to To have some tolerances also, what do you accept of your goal reaching condition both for the x&y position as well as for the orientation of your car. In the final pose, we have been talking a lot about calculating or computing different paths, saying that we have a starting location and we have a go location. And we have maybe one one path possibility that we could drive that goes like this in one path possibility that goes like this. So now as a human, you could of course immediately competitors and say, which of the two paths Do you like more, and I would assume that most of you would say, obviously, it would be nice to just drive a straight line into the goal. However, for the computer, we have to make it a little bit more explicit, we have to define metrics to to assess our paths. And one thing that we like to include metrics is a distance that is driven the as a general rule that that says, Yeah, shorter distance driven to the goal is probably better. And we

Unknown Speaker  31:12  
we have different ways of how we can calculate the distance. So here to the right, we have the example of the Manhattan distance, which means that we just have all these distances and x direction and all these distances in y direction. And what we do is we just add them, add them together, and then we have a nice, Manhattan distance calculated. However, of course, many variations are possible, we could just calculate the direct Euclidean distance, we could take into concern some kind of continuous curvature distance, we could consider reads cheftestants, we won't go into detail for these and also many other variations are possible. In practice. What does it mean for you to choose different metrics, it means that the resulting costs or actions that your vehicle assumes around it will be different. And this will have subtle impact on the actual path that your vehicle chooses in the end and that it drives. You can see that little by little we are adding more and more building blocks to an Altaf burning problem. Now we have said that it would be nice to take into concern for the assessment or different paths. The the distance driven, also already said that maybe other aspects could be interesting to take into concern when we choose our path. And here we have summarised some of them on this slide. So finding an optimal path requires to define optimality. The computer needs to know what it means to be to have an optimal path. And we can develop a cost function that map's a path or a part of a path to a cost which can be expressed as a scalar value. And we can also have different kinds of cost functions that we then combine into one common cost function. Now let's look at a few examples. We already discussed the distance, which we just said it would be maybe nice to drive the shortest path to the goal. But then also, if you imagine that you're sitting in the car, if we're steering a lot, in order to achieve this left, right, left and right, maybe this could be very good for keeping our total driven distance short, but it would maybe be very uncomfortable. If you're sitting in the vehicle, similar changes of direction, you might not want to have too many of them. And maybe you don't want strong, uncomfortable accelerations. Maybe it would be nice to drive too close to obstacles. Let's draw very small example for this year. So we have our car in blue, and we have the wall in green. And the question is if we if something like this would be more trustworthy for the passengers then this or not. So here while you're coming very close to the obstacles. This might make the bike make the passengers nervous, even though it might be the shorter path. Now, these are some slides that that almost would have a better place in your mathematics lectures and in this one specifically, but we always leave them in there because it's very important for students to be aware that these gone into the system transformations are very necessary. However, we will not go into details and except instead to assume that you I've already noticed or you work through it. yourself. So first of all, you should figure out the definitions of the coordinate systems that you're using. And depending on the simulators that you're using, depending on the hardware or software components that you're using, this might actually be different and is a constant source of headaches and errors for people. So figure out how your coordinate systems are defined. And then as we already saw in the robinus lecture, the the the different coordinate systems can have different values for us, we can use them for

Unknown Speaker  35:37  
for different purposes. In the image, you see that there is a vehicle and the vehicle is somehow defined with regards to the global coordinate system, there could be a local coordinate system, and then there can be an obstacle coordinate system. In the revenues lecture, we saw quite a few, quite a few of coordinate systems that can be used for autonomous driving in combination. And we need to be able to move all our information between these coordinate systems. From your mathematics lectures, you should remember that you can rotate coordinate systems, you can perform translations within coordinate systems. And what we provide here is just the mathematical guideline for how to rotate and translate between your different coordinate systems through matrix multiplication. Where were in a nice way to do it is to combine everything into one step with just the version that is described here. And this also offers a small example that you can calculate for yourself. Now, on the one end, I'm saying you can calculate this for yourself, it's nice example, you can find lots of information about it, and it belongs more strongly into your mathematics lecture. So this, I think you should be able to get to yourself. And then here you have the general rule that would define transformations can be trained. And now with regards to this lecture, it is important to understand that typically, you abstract these things away. So the the transformations between the different coordinate systems, that is just any work that you automate. And what's important are the different links between the different coordinate systems, which you achieve through calibration. Because if you add, for example, a sensor into your vehicle, then another sensor to your vehicle and both perceive your environment, you need to know very exactly how both relate to each other. And sometimes it's can be difficult to measure. So the whole domain of sensor calibration and just this field. But what you want to do is define all these links between the different coordinate systems automate the transformation processes, identify the necessary transmission parameters through the calibration process. And then you don't have to get you don't need to worry about it anymore, unless the the calibration would change. So here's an example that you can study. Or you can make other examples for yourself.

Unknown Speaker  38:31  
There are many potential error sources here. Again, this is not one of the real challenges for autonomous driving. But it is a very practical headache for many people when they implement their first autonomous vehicle software. So let's mention it here when we're working with angles. Just as an example, you can't just say, for two given angles, if you want the average, then you get it by adding them and dividing by two. Because if you would, for example, imagine a very small positive angle and this very small negative angle, and you express them here as Sita equals 0.1 and theta two equals two pi minus 0.1, then the average of that would be pi, which would of course be over here, I would be completely wrong. So be careful with your angles. Now, we can't really make good paths if we don't know how to check our paths if they are collision free. So what do we have to check we have to check whether a robot in a configuration queue intersects with an obstacle. We have to find the distance from a robot in a configuration queue to the closest obstacle. We have to have some way of representing the obstacle. We can represent it as a geometric primitives route such as polygon Or circles, we can provide our environment is a list of separate obstacle objects, we can represent each object as a polygon. Or we can make a grid map, as we discussed the robinus lecture to represent occupied cells around us. Another well known approach to this is using something as the Minkowski sum, as part of the configuration space, the configuration space contains all possible configurations of the robot where configuration isn't, in this case, an X Y position. And it could also be an orientation if the robot is able to rotate. And in this configuration space, we can represent obstacles to the Minkowski sum means that we take the shape of the robot here. And we assume that it cannot rotate. And we have the obstacle. And now we would add the robot to the obstacle nap. And they are different ways of how people do this most important is a city or whatever you do do it consistently. And you don't make logic errors while you do it. But if you see here you at the shape of the robot through all parts of the obstacle, you could maybe get a shape that is like this. And as long as you say that you don't enter the don't enter the this blue area, which is shown over here, where you could also imagine that the the actual obstacle is somehow inside here, then you would not have a collision. So as long as you don't rotate, and you just set your, the, the shape of your robot to your obstacles, this would make for conservative approach, where as long as you don't drive into the shape, you can be sure that you have not managed to do. More detailed descriptions of this do exist similar also exemplary algorithmic implementations that you gather would be interesting for you to check out if you're curious, to comments from this slide. So I said, we're just assuming that the robot doesn't rotate. However, many robots do rotate in practice, which means that the configuration space becomes more complex, when you add fita as a third dimension to the rotation of your robot. In practice, this could mean that if you rotate the robot like this, then you can also calculate a new Minkowski sum where you know, instead at this kind of shape around the robot.

Transcribed by https://otter.ai
